{
  "name": "finish",
  "description": "Provides a single callback for multiple asynchronous calls",
  "main": "./finish",
  "author": {
    "name": "Chaoran Yang",
    "email": "chaorany@me.com"
  },
  "version": "0.6.2",
  "repository": {
    "type": "git",
    "url": "http://github.com/chaoran/node-finish.git"
  },
  "bugs": {
    "url": "http://github.com/chaoran/node-finish/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/chaoran/node-finish/raw/master/LICENSE"
    }
  ],
  "keywords": [
    "finish",
    "async"
  ],
  "readme": "# Finish\n\n__Finish__ is a __high performance__ nodejs flow control utility that captures\ncompletion of multiple asynchronous calls with a single callback.\n\n## Installation\nYou can install using Node Package Manager (npm):\n\n    npm install finish\n\n## Quick Examples\n```javascript\nvar finish = require(\"finish\");\nfinish(function(async) {\n  // Any asynchronous calls within this function will be captured\n  // Just wrap each asynchronous call with function 'async'.\n  // Each asynchronous call should invoke 'done' as its callback.\n  // 'done' tasks two arguments: error and result.\n  async(function(done) { fs.readFile('hello.txt', done); }\n  async(function(done) { fs.readFile('world.txt', done); }\n}, function(err, results) {\n  // This callback is invoked after all asynchronous calls finish\n  // or as soon as an error occurs\n  // results is an array that contains result of each asynchronous call\n  console.log(results[0], results[1]);\n});\n```\n\n## API\n\nFinish provides four APIs:\n\n```javascript\nfinish(func[, reducer[, initialValue]], callback);\nfinish.map(array, async[, reducer[, initialValue]], callback);\nfinish.ordered(func[, reducer[, initialValue]], callback);\nfinish.ordered.map(array, async[, reducer[, initialValue]], callback);\n```\n\n### finish\n#### Syntax\n```javascript\nfinish(func[, reducer[, initialValue]], callback)\n```\n\n#### Parameters\n* `func`: function that makes asynchronous calls, taking one argument:\n  * `async([key, ]done)`: wrapper function that wraps an asynchronous call.\n    * `key`(__optional__): If provided, result of this call will be added as a\n      property `key` of the final `results` object. (See below.)\n    * `done`: callback function for individual asynchronous calls, taking two\n      arguments:\n      * `err`: any truthy value of __err__ will cause the final `callback` to\n        be invoked immediately.\n      * `result`: return value of the asynchronous call; it is captured by the\n        final `results`.\n* `reducer`(__optional__): reduction function to execute on each result, taking\n  two arguments:\n  * `previousValue`: The value previously returned in the last invocation of\n    the `reducer`, or `initialValue`, if supplied.\n  * `currentValue`: The current `result` returned by an asynchronous call.\n  * `key`: the `key` associated with the `async` call if provided.\n* `initialValue`(__optional__): Object to use as the first argument to the first\n  call of the `reducer`. It omitted, the first `result` returned by any\nasynchronous call will be used as `initialValue`. This argument should only be\nused when an `reducer` is presented.\n* `callback`: The final callback that will be invoked when all asynchronous\n  calls complete or an error occured, taking two arguments:\n  * `err`: If an error occured, `err` is the error. Otherwise, __null__.\n  * `results`: An array of `result` objects returned by all asynchronous\n    calls. The order of elements of `results` are not guaranteed (See\n`finish.ordered` if order guarantee is needed). If the optional `key` argument\nis used in the first `async` call, `results` will be an object with __null__ as\nprototype; `result` will be properties of `results`.\n\n#### Description\n`finish` is the free form of finish utility. One should wrap each asynchronous\ncall with `async` and the asynchronous call should invoke `done` as callback.\nNote that it is __safe__ to pass an function to `async` that executes\n__synchronous__. `result` objects passed to `done` is collected into an array if\nthe optional `key` parameter of `async` is not used. The order of `result`\nobjects in `results` are not guaranteed. When `key` parameter is used in\n`async`, `results` will be an object that has __null__ as prototype; each\n`result` will be an property in `results` at the associated `key`.\n\nWhen using an reducer, the reducer is invoked at every `done` callback with\n(`results`, `result`) as arguments. The final `results` is the return value of\nthe last invocation of reducer. The order of reducer invocation is __not__\nguaranteed. One should not use a reducer if `key` argument of `async` is used.\n\n#### Examples\n```javascript\nfinish(function(async) {\n  async(function(done) {\n    setTimeout(function() { done(null, 1); }, 100);\n  });\n  async(function(done) {\n    setTimeout(function() { done(null, 2); }, 100);\n  });\n}, function(err, results) {\n  assert.equal(results, [ 1, 2 ]);\n});\n\n// \"keyed\" finish\nfinish(function(async) {\n  async(\"one\", function(done) {\n    setTimeout(function() { done(null, 1); }, 100);\n  });\n  async(\"two\", function(done) {\n    setTimeout(function() { done(null, 2); }, 200);\n  });\n}, function(err, results) {\n  assert.equal(results, { one: 1, two: 2 });\n});\n\n// with a reducer\nfinish(\n  function(async) {\n    async(function(done) {\n      setTimeout(function() { done(null, 1); }, 100);\n    });\n    async(function(done) {\n      setTimeout(function() { done(null, 2); }, 200);\n    });\n  },\n  function(prev, curr) { return prev + curr; }, // reduction operator\n  0, // initial value (can be omitted in this case)\n  function(err, results) { assert.equal(results, 3); }\n);\n```\n\n### finish.map\n#### Syntax\n```javascript\nfinish.map(array, async[, reducer[, initialValue]], callback)\n```\n\n#### Parameters\n* `array`: An array of elements or an object.\n* `async`: If `array` is an instance of Array, `async` will be invoked on every\n  element of `array`. Otherwise, `async` will be invoked on `array`'s own\nenumerable properties. Depends on how many arguments `async` expects, `async` is\ninvoked with: `(value, done)`, `(value, index, done)`, and `(value, index,\narray, done)`.\n  * `element`: the value of the element or property;\n  * `index`: the index of the element or the key of the property;\n  * `array`: the array or object being traversed;\n  * `done`: the callback function for the asynchronous call (Same as in\n    `finish`).\n* `reducer`(__optional__): Same reduce function as in `finish`. It takes four\n  arguments:\n  * `previousValue`: Same as in `finish`.\n  * `currentValue`: Same as in `finish`.\n  * `index`: The index of the corresponding element in `array`, or the\n    property name of the corresponding property in `array` object.\n  * `array`: The same `array` passed to `finish.map`.\n* `initialValue`(__optional__): Same as in `finish`.\n* `callback`: Same as in `finish`.\n\n#### Descriptions\nThis is an syntactic sugar for `finish`. It maps the `async` function onto each\nelement (or property, if `array` is not an instance of Array) of `array`. Like\n`finish`, the order of execution is __not__ guaranteed either.\n\n#### Examples\n```javascript\n// map an array\nfinish.map([1, 2, 3], function(value, done) {\n  setTimeout(function() { done(null, value); });\n}, function(err, results) {\n  assert.equal(results, [1, 2, 3]);\n});\n\n// map an object\nfinish.map({ one: 1, two: 2, three: 3}, function(value, done) {\n  setTimeout(function() { done(null, value); });\n}, function(err, results) {\n  assert.equal(results, { one: 1, two: 2, three: 3 });\n});\n```\n\n### finish.ordered\n#### Syntax\n```javascript\nfinish.ordered(func[, reducer[, initialValue]], callback)\nfinish.ordered.map(array, async[, reducer[, initialValue]], callback)\n```\n\n#### Description\nThese two functions is the same as `finish` and `finish.map` with the addition\nof order guarantee. The order of `result` objects in `results` are guaranteed to\nbe the same as the order of invocation of asynchronous calls. If using a\nreducer, the reducer is invoked in the same order as the asynchronous calls\nspawned.\n\n## Why not use Async.parallel?\n\n[Async.parallel](http://github.com/caolan/async#parallel) accepts an array of\ncontinuation functions and runs them in parallel. It also provides a callback\nfunction which is fired after all functions finish.  Finish differs from\nasync.parallel because it does not require user to pack asynchronous calls into\nan array to run them in parallel and track their completion. This gives you more\nflexibility and greatly reduce the lines of plateboiler code you need to write\nwhen using Async.parallel.  Moreover, it increase parallelism, which gives you\nbetter performance.\n\n## Performance: finish vs. async.parallel\n\nExamples folder contains an example which calculates a size of a directory,\nimplemented in both finish and async.parallel.\nHere's how they perform on my macbook:\n\n    $ time node size.js $HOME\n    /Users/chaorany: 109295.691 MB\n\n    real  0m11.690s\n    user  0m11.956s\n    sys 0m20.838s\n\n    $ time node size-async.js $HOME\n    /Users/chaorany: 109295.691 MB\n\n    real  0m14.348s\n    user  0m14.679s\n    sys 0m21.068s\n\n",
  "readmeFilename": "README.md",
  "_id": "finish@0.6.2",
  "dist": {
    "shasum": "1d79cf4b7c9a0a2afc3a283ab87bc8c4895a711e",
    "tarball": "http://registry.npmjs.org/finish/-/finish-0.6.2.tgz"
  },
  "_from": "finish@",
  "_npmVersion": "1.3.11",
  "_npmUser": {
    "name": "chaorany",
    "email": "chaorany@me.com"
  },
  "maintainers": [
    {
      "name": "chaorany",
      "email": "chaorany@me.com"
    }
  ],
  "directories": {},
  "_shasum": "1d79cf4b7c9a0a2afc3a283ab87bc8c4895a711e",
  "_resolved": "https://registry.npmjs.org/finish/-/finish-0.6.2.tgz"
}
